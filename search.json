[
  {
    "objectID": "index.html#om-boka",
    "href": "index.html#om-boka",
    "title": "Pythonmatte",
    "section": "Om boka",
    "text": "Om boka\nDenne boka inneheld ulike m√•tar ein kan nytta programmering p√• i matematikk (programfag p√• vgs).\nEg nyttar Python som programmeringsspr√•k gjennom heile boka üêç.\n\n\n\n\n\n\nOBS üöß üöß üöß\n\n\n\nBoka er under utvikling og vert oppdatert med ujamne mellomrom. Sist oppdatert: {{today}}\n\n\nFor dei spesielt interesserte er boka laga med Quarto. For √• l√¶re meir om Quarto-b√∏ker kan ein kikka her."
  },
  {
    "objectID": "index.html#om-meg",
    "href": "index.html#om-meg",
    "title": "Pythonmatte",
    "section": "Om meg",
    "text": "Om meg\nüîç Her kan du lesa meir om meg\n\nLogo: Programmer icons created by juicy_fish - Flaticon"
  },
  {
    "objectID": "sannsyn1.html",
    "href": "sannsyn1.html",
    "title": "Sannsyn og simulering (S1/S2)",
    "section": "",
    "text": "I det f√∏lgjande kapittelet skal me sj√• p√• korleis me kan simulera ulike stokastiske fors√∏k i Python. Me ser p√• alt fr√• enkle simuleringar i uniforme modellar, samansette fors√∏k, og vidare binomiske, hypergeometriske og normalfordelte fors√∏k. Me ser √≤g p√• hypotesetesting i Python."
  },
  {
    "objectID": "sannsyn-terningar.html#ein-terning",
    "href": "sannsyn-terningar.html#ein-terning",
    "title": "1¬† Terningar og intro til simulering",
    "section": "1.1 Ein terning üé≤",
    "text": "1.1 Ein terning üé≤\n\nterning = rng.integers(1, 7)\nprint(terning)\n\n6\n\n\n\n\n\n\n\n\nMerk\n\n\n\nHer er verdien terning eit heiltal (integer) st√∏rre eller lik 1 og mindre enn 7. Sidan det er heiltal me trekk er dermed \\[\\text{terning} \\in \\{1, 2, 3, 4, 5, 6\\}\\]\n\n\nFor √• trilla fleire terningar kan me anten bruka l√∏kker:\n\nfor i in range(10):\n    print(rng.integers(1, 7))\n\n3\n4\n1\n6\n5\n2\n1\n5\n1\n5\n\n\neller s√• kan me legga inn eit argument size i integers. D√• blir output ein array (ein form for liste) med size terningar:\n\nterningar = rng.integers(1, 7, size=10)\nprint(terningar)\n\n[2 3 4 6 1 1 1 1 6 6]\n\n\nNo har me det me treng for √• kunna simulera eit stokastisk fors√∏k og estimera sannsyn ut fr√• simuleringa. Til d√∏mes kan me pr√∏va √• finna ut av kor sannunleg det er √• trilla 5 eller 6 p√• ein terning:\n\nN = 1000000 # tal simuleringar\n\nterningar = rng.integers(1, 7, size=N)\n\ngunstige = sum(terningar &gt;= 5)\n\nsannsyn = gunstige / N\n\nprint(f\"Sannsynet for 5 eller 6 er {sannsyn:.4f}\")\n\nSannsynet for 5 eller 6 er 0.3336\n\n\n\n\n\n\n\n\nForklaring: gunstige = sum(terningar &gt;= 5)\n\n\n\n\n\nFor √• forst√• denne ser me p√• eit d√∏me:\n\narray = np.array([1, 2, 3, 4, 5, 6])\n\nst√∏rre_enn_3 = array &gt; 3\n\nprint(array)\nprint(st√∏rre_enn_3)\nprint(sum(st√∏rre_enn_3))\n\n[1 2 3 4 5 6]\n[False False False  True  True  True]\n3\n\n\nAlts√• gjer me om verdiar til True eller False. Python reknar True som 1 og False som 0. N√•r me d√• summerer alle elementa i array f√•r me antall True i arrayen."
  },
  {
    "objectID": "sannsyn-terningar.html#fleire-terningar",
    "href": "sannsyn-terningar.html#fleire-terningar",
    "title": "1¬† Terningar og intro til simulering",
    "section": "1.2 Fleire terningar üé≤ üé≤",
    "text": "1.2 Fleire terningar üé≤ üé≤\nSp√∏rsm√•l som ‚ÄúKva er sannsynet for at produktet av to terningar er 8 eller mindre‚Äù er fint √• finna svar p√• ved hjelp av simulering:\n\nN = 1000000\n\nterning1 = rng.integers(1, 7, size=N)\nterning2 = rng.integers(1, 7, size=N)\n\nprodukt = terning1 * terning2\ngunstige = sum(produkt &lt;= 8)\nsannsyn = gunstige / N\n\nprint(f\"Sannsynet er {sannsyn:.4f}\")\n\nSannsynet er 0.4452\n\n\n\n\n\n\n\n\nForklaring: produkt = terning1 * terning2\n\n\n\n\n\nKodelinja finn produktet av element p√• samme plass i dei to arrayane. Sjekk d√∏met:\n\na = np.array([1, 2, 3, 4, 5])\nb = np.array([6, 7, 8, 9, 10])\n\nc = a * b\n\nprint(c)\n\n[ 6 14 24 36 50]\n\n\n\\(1\\cdot 6 = 6\\) og \\(2\\cdot 7 = 14\\)‚Ä¶"
  },
  {
    "objectID": "sannsyn-terningar.html#n√∏yaktighet",
    "href": "sannsyn-terningar.html#n√∏yaktighet",
    "title": "1¬† Terningar og intro til simulering",
    "section": "1.3 N√∏yaktighet üéØ",
    "text": "1.3 N√∏yaktighet üéØ\nSjekkar kva som skjer n√•r me triller fleire og fleire terningar (eller ein terning fleire gongar). For √• visa samanhengen plottar me resultatet. I d√∏met ser me p√• sannsynet for √• trilla 4 p√• ein terning.\n\nimport matplotlib.pyplot as plt\n\n# antall kast\nN = 10000000\n\n# triller terningar\nterningar = rng.integers(1, 7, size=N)\n\n# finn den kumulative summen av terningar som er lik 4\nkumulativ_sum = np.cumsum(terningar == 4)\n\n# lager \"x-akse\" fr√• 1 til N\nx = np.arange(1, N + 1)\n\n# finn relativ frekvens\nrel_frekvens = kumulativ_sum / x\n\nplt.figure(figsize=(10, 5))                      # lagar ein figur med 10x5 m√•l\nplt.hlines(1/6, 0, N, color=\"red\")               # teiknar ein linje med farge \"red\" for den teoretiske verdien\nplt.plot(x, rel_frekvens)                        # plottar x-akse og y-akse    \nplt.xscale(\"log\")                                # logaritmisk x-akse\nplt.xlabel(\"Antall kast \\n merk: log. skala\")    # namn p√• x-aksen\nplt.ylabel(\"Relativ frekvens\")                   # namn p√• y-aksen\nplt.title(\"Relativ frekvens for terningar\")      # tittel p√• figur\nplt.show()\n\n\n\n\nHer ser me at di fleire kast me gjennomf√∏rer, di n√¶rare kjem den relative frekvensen den teoretiske verdien for √• trilla ein firar p√• vanleg terning.\n\\[ P(\\text{firar}) = \\frac{1}{6} \\approx 0.167 \\]"
  },
  {
    "objectID": "sannsyn-samansette_forsok.html#teoretisk-sannsyn",
    "href": "sannsyn-samansette_forsok.html#teoretisk-sannsyn",
    "title": "2¬† Samansette fors√∏k - choice",
    "section": "2.1 Teoretisk sannsyn",
    "text": "2.1 Teoretisk sannsyn\nF√∏rst kan me sj√• p√• kva det teoretiske sannsynet er for desse to. Ofte n√•r me bruker simulering er det fordi det er vanskeleg √• finna svaret ved rekning, men i dette d√∏met er det ikkje s√• vanskeleg.\nMed tilbakelegging\n\\[\nP(\\text{BB}) = \\frac{7}{10} \\cdot \\frac{7}{10} = \\frac{49}{100} = 0.490\n\\]\nUtan tilbekelegging \\[\nP(\\text{BB}) = \\frac{7}{10} \\cdot \\frac{6}{9} = \\frac{42}{90} \\approx 0.467\n\\]"
  },
  {
    "objectID": "sannsyn-samansette_forsok.html#simulering-av-twist-trekket",
    "href": "sannsyn-samansette_forsok.html#simulering-av-twist-trekket",
    "title": "2¬† Samansette fors√∏k - choice",
    "section": "2.2 Simulering av twist-trekket",
    "text": "2.2 Simulering av twist-trekket\n\n# importerar og lagar ein random generator\nfrom numpy.random import default_rng\nrng = default_rng()\n\n# antall simuleringar\nN = 1000000\n\n# lagar liste med twistsk√•la\ntwistsk√•l = [\"Banan\"]*7 + [\"Daim\"]*3\n\n# skriv ut twistsk√•la\nprint(twistsk√•l)\n\n['Banan', 'Banan', 'Banan', 'Banan', 'Banan', 'Banan', 'Banan', 'Daim', 'Daim', 'Daim']\n\n\n\n2.2.1 Med tilbakelegging\n\nBB = 0\n\nfor i in range(N):\n    twist = rng.choice(twistsk√•l, size = 2)\n    if twist[0] == \"Banan\" and twist[1] == \"Banan\":\n        BB += 1\n\nrel_frek = BB/N\n\nprint(f\"Sannsynet for at me trekk to banantwist er {rel_frek}\")\n\nSannsynet for at me trekk to banantwist er 0.489409\n\n\n\n\n\n\n\n\nTips\n\n\n\nFor ein litt meir elegant kode kan me droppa if-setningen i l√∏kka v√•r. Dette kan me gjera ved √• gjera ein boolsk variabel (True eller False) om til eit heiltal. D√• blir True = 1 og False = 0\n\nBB = 0\n\nfor i in range(N):\n    twist = rng.choice(twistsk√•l, size = 2)\n    BB += int(twist[0] == \"Banan\" and twist[1] == \"Banan\")\n\nrel_frek = BB/N\n\nprint(f\"Sannsynet for at me trekk to banantwist er {rel_frek}\")\n\nSannsynet for at me trekk to banantwist er 0.489524\n\n\n\n\nMe kan sj√• kor langt unna den teoretiske verdien me kjem:\n\nfeil = abs(rel_frek - 49/100) \nprint(f\"Feilen blir {round(feil, 6)} n√•r me gjer {N} simuleringar\")\n\nFeilen blir 0.000476 n√•r me gjer 1000000 simuleringar\n\n\nDersom me vil ha eit enno meir n√∏yaktig resultat kan me gjera fleire simuleringar, dette kjem me litt attende til seinare. Merk at programmet vil fort ta ganske lang tid √• k√∏yra etter kvart som talet p√• simuleringar aukar.\n\n\n2.2.2 Utan tilbakelegging\nForskjellen blir ikkje stor her. Det einaste me gjer er √• legga til replace = False som argument i choice-funksjonen\n\nBB = 0\n\nfor i in range(N):\n    twist = rng.choice(twistsk√•l, size = 2, replace = False)\n    if twist[0] == \"Banan\" and twist[1] == \"Banan\":\n        BB += 1\n\nrel_frek = BB/N\n\nprint(f\"Sannsynet for at me trekk to banantwist er {rel_frek}\")\n\nSannsynet for at me trekk to banantwist er 0.466383\n\n\n\nfeil = abs(rel_frek - 42/90) \nprint(f\"Feilen blir {round(feil, 6)} n√•r me gjer {N} simuleringar\")\n\nFeilen blir 0.000284 n√•r me gjer 1000000 simuleringar"
  },
  {
    "objectID": "sannsyn-samansette_forsok.html#ikkje-uniforme-sannsynsmodellar",
    "href": "sannsyn-samansette_forsok.html#ikkje-uniforme-sannsynsmodellar",
    "title": "2¬† Samansette fors√∏k - choice",
    "section": "2.3 Ikkje uniforme sannsynsmodellar",
    "text": "2.3 Ikkje uniforme sannsynsmodellar\nDette d√∏met me har sett p√• er eit d√∏me p√• ein ikkje-uniform sannsynsmodell, sidan sannsynet for Banan og Daim ikkje er det same. I starten laga me ei liste med alle twistane i sk√•la. I dette d√∏met er det praktisk, sidan me har eit lite utfallsrom (banan og daim) og kontroll p√• kor mange det er av kvar.\nAv og til kan det vera nyttig √• definera ikkje-uniforme sannsynsmodellar p√• ein litt anna m√•te.\n\ntwistar = [\"Banan\", \"Daim\"]\nsannsyn = [7/10, 3/10]\n\nto_twist = rng.choice(twistar, size = 2, p = sannsyn)\n\nprint(f\"Me trekk {to_twist}\")\n\nMe trekk ['Banan' 'Daim']\n\n\nDette kan brukast viss me veit utfallsrommet og sannsynet for kvart av utfalla, ikkje n√∏dvendigvis antallet. F.eks. blodtype hos tilfeldige personar i befolkningen."
  },
  {
    "objectID": "sannsyn-ulike_fordelingar.html#binomisk-sannsyn",
    "href": "sannsyn-ulike_fordelingar.html#binomisk-sannsyn",
    "title": "3¬† Simulering av ulike fordelingar",
    "section": "3.1 Binomisk sannsyn",
    "text": "3.1 Binomisk sannsyn"
  },
  {
    "objectID": "sannsyn-ulike_fordelingar.html#hypergeometrisk-sannsyn",
    "href": "sannsyn-ulike_fordelingar.html#hypergeometrisk-sannsyn",
    "title": "3¬† Simulering av ulike fordelingar",
    "section": "3.2 Hypergeometrisk sannsyn",
    "text": "3.2 Hypergeometrisk sannsyn"
  },
  {
    "objectID": "sannsyn-ulike_fordelingar.html#normalfordelt-sannsyn",
    "href": "sannsyn-ulike_fordelingar.html#normalfordelt-sannsyn",
    "title": "3¬† Simulering av ulike fordelingar",
    "section": "3.3 Normalfordelt sannsyn",
    "text": "3.3 Normalfordelt sannsyn"
  },
  {
    "objectID": "sannsyn-hypotesetesting.html",
    "href": "sannsyn-hypotesetesting.html",
    "title": "4¬† Hypotesetesting",
    "section": "",
    "text": "print(\"Kjem etterkvart\")\n\nKjem etterkvart"
  },
  {
    "objectID": "folgerogrekker.html",
    "href": "folgerogrekker.html",
    "title": "F√∏lgjer og rekker (S2/R2)",
    "section": "",
    "text": "I dette kapittelet skal me sj√• p√• korleis me kan bruka Python til √• arbeida med f√∏lgher og rekker.\nEi talf√∏lgje er ein serie tal. Dei kjem p√• ulike formar. Eit d√∏me p√• ei talf√∏lgje er:\n\nfor i in range(1, 6):\n    print(i, end=\",\")\n\nprint(\"...\")\n\n1,2,3,4,5,...\n\n\nDette kjenner me att som dei 5 f√∏rste naturlege tala, \\(\\mathbb{N}\\), og er eit enkelt d√∏me p√• ei talf√∏lgje. Kvart av tala i f√∏lgja kallar me for ledd. Det f√∏rste leddet vert kalla \\(a_1\\) medan det \\(n\\)-te leddet vert kalla \\(a_n\\).\nVidare i kapittelet skal me sj√• p√• ulike typer talf√∏lgjer, eksplisitte og rekursive funksjonar for √• finna ledd i talf√∏lgjer. Vidare ser me p√• ulike typer rekker. F√∏r me mot slutten ser p√• nokre d√∏me p√• praktisk bruk av f√∏lgjer og rekker (l√•n og sparing)."
  },
  {
    "objectID": "f√∏lger.html#aritmetiske-f√∏lgjer",
    "href": "f√∏lger.html#aritmetiske-f√∏lgjer",
    "title": "5¬† F√∏lgjer",
    "section": "5.1 Aritmetiske f√∏lgjer",
    "text": "5.1 Aritmetiske f√∏lgjer\nEit anna d√∏me p√• ei aritmetisk talf√∏lgje er denne\n\\[ 3, 7, 11, 15, ...\\]\nHer ser me at det f√∏rste leddet \\(a_1 = 3\\) og at differansen \\(d=4\\).\nAt det er ein fast differanse mellom kvart av ledda betyr at dersom me skal finna eit ledd (\\(a_n\\)), m√• me ta leddet f√∏r (\\(a_{n-1}\\)) og legga til differansen (\\(d\\)). Dermed f√•r me\n\\[a_{n} = a_{n-1} + d\\]\nFr√• d√∏met over ser me at det stemmer, \\(7 = 3 + 4\\) og \\(11 = 7 + 4\\) osb.\n\n5.1.1 Rekursiv formel for ledd n\nSamanhengen over kan me nytta for √• finna \\(a_n\\) rekursivt. Rekursjon handlar om gjentaking, s√• tanken er at me kan gjenta formelen for √• finna ledd \\(n\\). Me kan laga ein funksjon som kun tek utgangspunkt i opplysningen om at \\(a_{n} = a_{n-1} + d\\).\n\ndef a(n):\n    return a(n-1) + 4\n\nprint(a(4))\n\nRecursionError: maximum recursion depth exceeded\n\n\nMen om du pr√∏ver √• k√∏yra denne koden vil du f√• ein feil:\n\nRecursionError: maximum recursion depth exceeded\n\nOm du ser p√• koden, ser du kanskje kva som er problemet?\nDet let seg l√∏ysa om me definerer ein rekursjonsbotn (i dette tilfellet \\(a_1\\)). Me pr√∏ver p√• nytt:\n\ndef a(n):\n    if n == 1:\n        return 3\n    else: \n        return a(n-1) + 4\n\nprint(a(4))\n\n15\n\n\nDenne funksjonen kan me bruka for √• t.d. skriva ut dei 10 f√∏rste ledda i f√∏lgja:\n\nfor i in range(1, 11):\n    print(a(i), end = \", \")\n\nprint(\"...\")\n\n3, 7, 11, 15, 19, 23, 27, 31, 35, 39, ...\n\n\nUlempen med denne rekursive funksjonen er at han m√• gjennom alle dei f√∏reg√•ande ledda for kvart ledd du bruker han for √• finna. S√• om du skal finna \\(a_1000\\) vil formelen finna alle ledda f√∏r. Og p√• nytt n√•r du ser etter \\(a_1001\\)‚Ä¶ Det kan fort bli b√•de tidkrevjande og tungvint, sj√∏lv for datamaskina.\n\n\n5.1.2 Eksplisitt formel for ledd n\nMe kan sj√• om me finn ein eksplisitt m√•te √• finna \\(a_n\\) p√• (alts√• finna direkte, utan rekursjon). Me ser p√• d√∏met igjen.\n\\[3, 7, 11, 15, ...\\]\nMe ser at \\[\n    \\begin{aligned}\n        a_2 &= 7 = 3 + 4 \\\\\n        a_3 &= 11 = 7 + 4 = 3 + 4 + 4 \\\\\n        a_4 &= 15 = 11 + 4 = 7 + 4 + 4 = 3 + 4 + 4 + 4\n    \\end{aligned}\n\\]\nAlts√• er \\[a_n = a_1 + (n-1)d\\] som me kan programmera som\n\ndef a(n):\n    return 3 + (n-1)*4\n\nprint(a(4))\n\n15\n\n\nOg igjen kan me skriva ut dei ti f√∏rste ledda:f\n\nfor i in range(1, 11):\n    print(a(i), end=\", \")\n\nprint(\"...\")\n\n3, 7, 11, 15, 19, 23, 27, 31, 35, 39, ..."
  },
  {
    "objectID": "rekker1.html",
    "href": "rekker1.html",
    "title": "6¬† Rekker",
    "section": "",
    "text": "a = \"test\""
  },
  {
    "objectID": "funksjonar.html",
    "href": "funksjonar.html",
    "title": "Funksjonar (S1/S2/R1/R2)",
    "section": "",
    "text": "plotting\nkurvetilpassing / modellering\nderivasjon\nintegrasjon"
  },
  {
    "objectID": "funksjonar-plotting.html#funksjonar-med-delt-forskrift",
    "href": "funksjonar-plotting.html#funksjonar-med-delt-forskrift",
    "title": "7¬† Plotting",
    "section": "7.1 Funksjonar med delt forskrift",
    "text": "7.1 Funksjonar med delt forskrift\nNokre funksjonar kan ha ulik definisjon p√• ulike intervall. Desse kallar me funksjonar med delt forskrift. Me ser p√• funksjonen\n\\[f(x) = \\begin{cases}\nx^2 & \\text{for } x \\leq 0 \\\\\nx & \\text{for } x &gt; 0\n\\end{cases}\\]\nDenne kan definerast med numpy.piecewise().\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nStartar med √• definera funksjonen. Det gjer me med\nnumpy.piecewise(x, condlist, funclist)\nder condlist er ei liste med betingelse/intervall og funclist funksjonane i same rekkef√∏lge\n\ndef f(x):\n    return np.piecewise(x, [x &lt;= 0, x &gt; 0], [lambda x: x**2, lambda x: x])\n\n\n\n\n\n\n\nKva er lambda?\n\n\n\n\n\nlambda x: er kortversjonen av\n\ndef g(x):\n    return x**2\n\nDermed kan me heller definera funksjonen slik:\n\nx = np.linspace(-3,2,5)\ng = lambda x: x**2\n\ny = g(x)\n\n\n\n\nLagar ein array med 100 \\(x\\)-verdiar og finn vidare \\(y\\)-verdiane med funksjonen me definerte.\n\nx = np.linspace(-4,4,100)\ny = f(x)\n\nPlottar grafen:\n\nplt.plot(x, y)\n\n# pynt\nplt.axhline(0, color=\"black\")\nplt.axvline(0, color=\"black\")\nplt.grid()\nplt.show()\n\n\n\n\n\n7.1.1 Alternativ: if/else\nEin annan m√•te dette kan gjerast p√• er √• bruka betingelsar og l√∏kker. Dette kan me gjera slik:\n\n# definerer funksjonen\ndef f(x):\n    if x &lt;= 0:\n        return x**2\n    else:\n        return x\n\n# lager x-verdiar\nx_verdiar = np.linspace(-5, 5, 100)\n\n# rekner ut y-verdiane\ny_verdiar = [f(x) for x in x_verdiar]\n\n# plottar\nplt.plot(x_verdiar, y_verdiar)\n\n# pynt\nplt.axhline(0, color=\"black\")\nplt.axvline(0, color=\"black\")\nplt.grid()\nplt.show()\n\n\n\n\n\n\n7.1.2 Diskontinuerlege funksjonar\nFramgangsm√•ten over med piecewise kan brukast for funksjonar som er definert for alle \\(x\\)-verdiar mellom nederste og √∏verste del av definisjonsmengda. Om ein har ein funksjon med delt definisjonsmengde som td.\n\\[h(x) = \\begin{cases}\nx^2 & \\text{for } x \\leq 0 \\\\\n-x^2 & \\text{for } x \\geq 2\n\\end{cases}\\]\nm√• ein gjera tilpassingar. Pr√∏ver f√∏rst m√•ten me gjorde det over:\n\n# definerer funksjonen\ndef h(x):\n    return np.piecewise(x, [x &lt;= 0, x &gt;= 2], [lambda x: x**2, lambda x: -x**2])\n\n\n# finn x og y\nx = np.linspace(-4, 4, 100)\ny = h(x)\n\n# plottar\nplt.plot(x, y)\nplt.show()\n\n\n\n\nHer viser utfordringa med denne typen funksjonar. I staden for √• teikna to kurver som ikkje heng saman, vert funksjonsverdien \\(0\\) n√•r \\(x\\in \\langle 0, 2 \\rangle\\). I piecewise sin dokumentasjon finn me dette:\n\nThe output is the same shape and type as x and is found by calling the functions in funclist on the appropriate portions of x, as defined by the boolean arrays in condlist. Portions not covered by any condition have a default value of 0.\n\nM√•ten √• l√∏ysa det p√• er √• definera kva som skal skje i intervallet der funksjonen ikkje er definert:\n\n# definerer funksjonen (ogs√• mellom 0 og 2)\ndef h(x):\n    return np.piecewise(x, [x &lt;= 0, (x &gt; 0) & (x &lt; 2), x &gt;= 2], [lambda x: x**2, np.nan, lambda x: -x**2])\n\n\n# finn x og y\nx = np.linspace(-4, 4, 100)\ny = h(x)\n\n# plottar\nplt.plot(x, y)\nplt.show()\n\n\n\n\nHer er intervallet (x &gt; 0) & (x &lt; 2) definert ved funksjonen np.nan (not a number). P√• denne m√•ten unng√•r me at funksjonsverdien vert sett til 0 automatisk i mellomrommet mellom dei to intervalla som utgjer definisjonsmengda."
  },
  {
    "objectID": "funksjonar-derivasjon.html",
    "href": "funksjonar-derivasjon.html",
    "title": "8¬† Derivasjon",
    "section": "",
    "text": "print(\"...\")\n\n..."
  },
  {
    "objectID": "funksjonar-integrasjon.html#approksimering-av-integral",
    "href": "funksjonar-integrasjon.html#approksimering-av-integral",
    "title": "9¬† Integrasjon",
    "section": "9.1 Approksimering av integral",
    "text": "9.1 Approksimering av integral\nDet er fleire m√•tar me kan approksimera bestemte integral numerisk. I GeoGebra finn me funksjonane SumUnder og SumOver som gjev oss summen av arealet til \\(n\\) rektangel mellom \\(a\\) og \\(b\\) p√• \\(x\\)-aksen. Rektangla er litt for store eller litt for sm√•, som f√∏lgje av at den √∏verste sida ligg under eller over funksjonen. SumUnder vil dermed gje eit resultat som er litt mindre enn det faktiske resultatet, medan SumOver vil gje eit litt for stort resultat.\nAnimasjonen under viser korleis n√∏yaktigheita til SumUnder aukar etter kvart som antall rektangel vert st√∏rre. Med fleire rektangel vert arealet som ikkje vert dekka mindre og mindre.\n\n\n\nFigur¬†9.1: Animasjon av venstresum\n\n\nDen enklaste approksimasjonen er √• finna venstre- eller h√∏gresum. Med venstresum skal kvar av rektangla ha h√∏gde slik at hj√∏rnet √∏verst til venstre ligg p√• funksjonen. H√∏gresum finn me p√• same m√•te, men med hj√∏rnet √∏verst til h√∏gre p√• funksjonen. Algoritmen vert ganske lik for begge. Me ser p√• venstresum f√∏rst.\n\n9.1.1 Venstresum\nMe skal finna summen av \\(n\\) rektangel mellom \\(a\\) og \\(b\\) som er slik at hj√∏rnet √∏verst til venstre p√• kvart rektangel ligg p√• funksjonen. Breidda til rektangla kallar me \\(dx\\) (\\(\\Delta x\\) p√• figuren).\n\n\n\nFigur¬†9.2: Venstresum\n\n\n\ndef venstresum(f, a, b, n):\n    # finn bredden\n    dx = (b-a)/n\n\n    # startverdiar\n    x = a\n    sum_venstre = 0 \n\n    # finn arealet av kvart rektangel og legg arealet til totalen\n    for i in range(n):\n        rektangel = f(x)*dx\n        sum_venstre += rektangel\n        x += dx\n\n    # returnerer totalverdien\n    return sum_venstre\n\nTester algoritmen p√• funksjonen \\[f(x)=x^3+2x+3\\]\nPr√∏ver √• finna ein omtrentleg verdi for arealet under \\(f(x)\\) mellom \\(x=2\\) og \\(x=5\\). Pr√∏ver med \\(n=100\\).\n\ndef f(x):\n    return x**3 + 2*x + 3\n\n\nprint(f\"Venstresum: {venstresum(f, 2, 5, 100):.3f}\")\n\nVenstresum: 180.410\n\n\n\n\n9.1.2 H√∏gresum\nMe skal finna summen av \\(n\\) rektangel mellom \\(a\\) og \\(b\\) som er slik at hj√∏rnet √∏verst til h√∏gre p√• kvart rektangel ligg p√• funksjonen. Breidda til rektangla kallar me \\(dx\\). Funksjonen er heilt lik som i venstresum() men me endrar rektangel til f(x+dx)*dx slik at me reknar h√∏gda p√• h√∏gresida av rektangelet. Sj√• Figur¬†9.2\n\ndef h√∏gresum(f, a, b, n):\n    dx = (b-a)/n\n\n    x = a\n    sum_h√∏gre = 0 \n\n    for i in range(n):\n        rektangel = f(x+dx)*dx\n        sum_h√∏gre += rektangel\n        x += dx\n\n    return sum_h√∏gre\n\nTestar p√• samme funksjon og intervall som tidlegare:\n\nprint(f\"H√∏gresum: {h√∏gresum(f, 2, 5, 100):.3f}\")\n\nH√∏gresum: 184.100\n\n\nMed det kan me anta at arealet ligg ein stad mellom 180,41 og 184,10. Med andre ord \\[180.41 \\leq \\int_2^5 f(x)\\,dx \\leq 184.10\\]\nOm me aukar talet p√• rektangel vil me f√• ein betre approksimasjon:\n\nprint(f\"Venstresum: {venstresum(f, 2, 5, 1000):.3f}\")\nprint(f\"H√∏gresum: {h√∏gresum(f, 2, 5, 1000):.3f}\")\n\nVenstresum: 182.066\nH√∏gresum: 182.435\n\n\n\n\n9.1.3 Sum under og sum over\nMe kan laga algoritmar som fungerer p√• same m√•te som GeoGebra sine tidlegare nemnde SumUnder og SumOver. Me tek utgangspunkt i samme algoritme som tidlegare, men no m√• me sjekka kva for ei av sidene som er kortast (for SumUnder) eller lengst (for SumOver).\nSum under f√∏rst:\n\ndef sumunder(f, a, b, n):\n    dx = (b-a)/n\n\n    x = a\n    sum_under = 0 \n\n    # finn den kortaste sida og bruker den som h√∏gde\n    for i in range(n):\n        if f(x) &lt;= f(x+dx):\n            rektangel = f(x)*dx\n        else:\n            rektangel = f(x+dx)*dx\n\n        sum_under += rektangel\n        x += dx\n\n    return sum_under\n\nSum over blir heilt anaalogt, men me snur ulikskapen:\n\ndef sumover(f, a, b, n):\n    dx = (b-a)/n\n\n    x = a\n    sum_over = 0 \n\n    for i in range(n):\n        if f(x) &gt;= f(x+dx):\n            rektangel = f(x)*dx\n        else:\n            rektangel = f(x+dx)*dx\n\n        sum_over += rektangel\n        x += dx\n\n    return sum_over\n\nTester p√• funksjonen og intervallet fr√• tidlegare:\n\nprint(f\"Sum under: {sumunder(f, 2, 5, 100):.3f}\")\nprint(f\"Sum over: {sumover(f, 2, 5, 100):.3f}\")\n\nSum under: 180.410\nSum over: 184.100\n\n\nKva for ein av desse som fungerer best vil avhenga av funksjonen. Tenk gjerne litt p√• kva type funksjonar dei ulike passar godt eller d√•rleg til.\n\n\n9.1.4 Trapesmetoden\nEin veldig effektiv m√•te √• approksimera arealet under grafen p√• er √• laga trapes framfor rektangel. H√∏gda p√• trapeset vert dx medan dei to parallelle sidene vert f(x)og f(x+dx).\n\n\n\nFigur¬†9.3: Trapesmetoden\n\n\n\ndef trapesmetoden(f, a, b, n):\n    dx = (b-a)/n\n\n    x = a\n    sum_trapes = 0 \n\n    for i in range(n):\n        trapes = ((f(x)+f(x+dx))*dx)/2\n        sum_trapes += trapes\n        x += dx\n\n    return sum_trapes\n\n# tester med n=100\nprint(f\"Trapesmetode: {trapesmetoden(f, 2, 5, 100):.3f}\")\n\nTrapesmetode: 182.255\n\n\nMe reknar ut det bestemte integralet \\[\\int_2^5 x^3 +2x +3 \\, dx = \\frac{729}{4} = 182.25\\]\nHer ser me at me kjem n√¶rare svaret med 100 trapes enn med 1000 rektangel, s√• trapesmetoden er mykje meir n√∏yaktig."
  },
  {
    "objectID": "funksjonar-integrasjon.html#symbolsk-integrasjon-med-sympy",
    "href": "funksjonar-integrasjon.html#symbolsk-integrasjon-med-sympy",
    "title": "9¬† Integrasjon",
    "section": "9.2 Symbolsk integrasjon med SymPy",
    "text": "9.2 Symbolsk integrasjon med SymPy\n(her kjem litt om korleis ein kan integrera symbolsk med sympy / CAS i python)"
  },
  {
    "objectID": "miniconda.html#jupyter-lab",
    "href": "miniconda.html#jupyter-lab",
    "title": "Vedlegg A ‚Äî Tips til programmeringa",
    "section": "A.1 Jupyter lab",
    "text": "A.1 Jupyter lab\nEit godt verkt√∏y for √• laga, endra og k√∏yra jupyterfiler er Jupyter Lab. Dette programmet kan installerast p√• mange m√•tar. Mitt tips er √• installera det gjennom Miniconda. Dokumentasjonen til programmet finn du her"
  },
  {
    "objectID": "miniconda.html#miniconda",
    "href": "miniconda.html#miniconda",
    "title": "Vedlegg A ‚Äî Tips til programmeringa",
    "section": "A.2 Miniconda",
    "text": "A.2 Miniconda\n\nG√• inn p√• https://docs.conda.io/en/latest/miniconda.html\nLast ned den nyaste installasjonsfila  \nInstaller miniconda ved √• k√∏yra fila.\nOpne terminal p√• Mac og Anaconda Prompt p√• Windows. (P√• Mac kan du opna spotlight og s√∏ka etter programmet, p√• Windows kan du s√∏ka i start-menyen).\nI terminal/Anaconda Prompt skriv du desse kodelinjene (linje for linje)\nconda config --add channels conda-forge \nconda config --set channel_priority strict ‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã\nconda update -n base -c defaults conda \nconda install pandas matplotlib jupyterlab ipympl xarray python=3.11 \nconda install scipy sympy\nN√•r du skal bruke Jupyter lab opnar du terminal/Anaconda Prompt og skriv inn\njupyter lab"
  }
]